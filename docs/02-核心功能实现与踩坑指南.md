# 从零开始搭建微信扫码登录系统（下）：核心功能实现与踩坑指南

## 前言

大家好，我是 xiaou
在上一篇文章中，我们完成了微信扫码登录系统的架构设计和基础环境搭建。今天，我将和大家一起深入核心功能的实现，包括二维码生成、状态管理、消息路由等关键技术，以及我在开发过程中踩过的那些 "坑"。

## 二维码生成：一切的起点

### 生成二维码的API设计

二维码生成是扫码登录的第一步。用户点击"微信登录"按钮后，前端会调用后端接口获取一个临时的二维码。

```java
@PostMapping("qrcode-create")
public CommonResult<WxQrcodeGenerateRespVo> userQrcodeCreate(@RequestBody WxQrcodeGenerateReqVo reqVo) {
    // 切换到对应的公众号配置
    wxMpService.switchover(reqVo.getClientId());

    // 生成唯一的场景值
    String sceneStr = reqVo.getSceneType() + "#" + UUID.randomUUID();

    // 创建临时二维码（1小时有效期）
    WxMpQrCodeTicket wxMpQrCodeTicket = wxMpService.getQrcodeService()
            .qrCodeCreateTmpTicket(sceneStr, (int) TimeUnit.HOURS.toSeconds(1));

    // 获取二维码图片URL
    String qrcodeUrl = wxMpService.getQrcodeService()
            .qrCodePictureUrl(wxMpQrCodeTicket.getTicket());

    // 初始化二维码状态到Redis
    wxRedis.startQrcode(wxMpQrCodeTicket.getTicket(),
            new WxQrcodeLogin()
                    .setStatus(WxQrcodeStatus.WAIT_SCAN.getValue())
                    .setClientId(reqVo.getClientId()));

    // 返回结果
    WxQrcodeGenerateRespVo respVo = new WxQrcodeGenerateRespVo();
    respVo.setUrl(wxMpQrCodeTicket.getUrl());
    respVo.setTicket(wxMpQrCodeTicket.getTicket());
    respVo.setQrcodeUrl(qrcodeUrl);
    return CommonResult.success(respVo);
}
```

### 场景值的设计巧思

这里有一个巧妙的设计：使用`场景类型#UUID`的格式作为场景值。这样做的好处是：

1. **可扩展性**：支持多种二维码场景（登录、注册、支付等）
2. **唯一性**：UUID确保每个二维码都是唯一的
3. **可追溯**：后续可以根据场景值区分不同业务

## Redis状态管理：实时同步的魔法

### 为什么选择Redis？

扫码登录的核心是状态的实时同步。我们需要存储：

1. 二维码的当前状态（等待扫码、已扫码、已确认）
2. 扫码用户的OpenID
3. 登录成功后的Token

Redis非常适合这个场景，因为：
- **高性能**：毫秒级的读写响应
- **支持过期**：自动清理过期的二维码
- **原子操作**：保证状态更新的一致性

### 状态管理的实现

```java
@Component
@RequiredArgsConstructor
public class WxRedis {

    private static final String QRCODE_RESULT_PREFIX = "social:wx:qrcode:result:%s";
    private final StringRedisTemplate redisTemplate;

    // 初始化二维码（15分钟过期）
    public void startQrcode(String ticket, WxQrcodeLogin login) {
        String redisKey = String.format(QRCODE_RESULT_PREFIX, ticket);
        redisTemplate.opsForValue().set(redisKey,
                JsonUtils.toJsonString(login),
                15,
                TimeUnit.MINUTES);
    }

    // 用户扫码后更新状态（延长5分钟）
    public void scannedQrcode(String ticket) {
        String redisKey = String.format(QRCODE_RESULT_PREFIX, ticket);
        WxQrcodeLogin login = JsonUtils.parseObject(
                redisTemplate.opsForValue().get(redisKey),
                WxQrcodeLogin.class);

        if (login != null) {
            login.setStatus(WxQrcodeStatus.SCANNED.getValue());
            redisTemplate.opsForValue().set(redisKey,
                    JsonUtils.toJsonString(login),
                    5,
                    TimeUnit.MINUTES);
        }
    }

    // 登录成功（延长2分钟给前端获取）
    public void loginSuccess(String ticket, String token) {
        String redisKey = String.format(QRCODE_RESULT_PREFIX, ticket);
        WxQrcodeLogin login = JsonUtils.parseObject(
                redisTemplate.opsForValue().get(redisKey),
                WxQrcodeLogin.class);

        if (login != null) {
            login.setToken(token)
                  .setStatus(WxQrcodeStatus.CONFIRMED.getValue());
            redisTemplate.opsForValue().set(redisKey,
                    JsonUtils.toJsonString(login),
                    2,
                    TimeUnit.MINUTES);
        }
    }
}
```

## 消息路由：微信事件的精准分发

### 路由配置

微信服务器会推送各种事件（扫码、关注、取消关注等），我们需要精准地将这些事件路由到对应的处理器：

```java
@Bean
public WxMpMessageRouter messageRouter(WxMpService wxMpService) {
    final WxMpMessageRouter router = new WxMpMessageRouter(wxMpService);

    // 登录注册事件路由
    router.rule().async(false)
            .msgType(EVENT)
            .matcher((wxMessage) ->
                    WxConsts.EventType.SCAN.equals(wxMessage.getEvent())
                    || WxConsts.EventType.SUBSCRIBE.equals(wxMessage.getEvent()))
            .eventKeyRegex(WxQrcodeSceneType.LOGIN_OR_REGISTER.getEventKeyRegex())
            .handler(this.loginAndRegisterHandler)
            .end();

    // 普通关注事件路由
    router.rule().async(false)
            .msgType(EVENT)
            .event(WxConsts.EventType.SUBSCRIBE)
            .handler(this.subscribeHandler)
            .end();

    return router;
}
```

### 正则表达式的妙用

使用正则表达式匹配场景键是一个很好的实践：

```java
public String getEventKeyRegex() {
    return "^(qrscene_)?" + this.name() +"#.*";
}
```

这个正则表达式可以匹配：
- `LOGIN_OR_REGISTER#uuid`（扫码事件）
- `qrscene_LOGIN_OR_REGISTER#uuid`（关注并扫码事件）

## 扫码处理器：业务逻辑的核心

### 登录注册处理器

```java
@Component
@RequiredArgsConstructor
public class LoginAndRegisterHandler extends AbstractHandler {

    private final WxRedis wxRedis;

    @Override
    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage,
                                    Map<String, Object> context,
                                    WxMpService wxMpService,
                                    WxSessionManager sessionManager) {

        // 更新状态为已扫码
        wxRedis.scannedQrcode(wxMessage.getTicket());

        // 获取用户信息
        WxMpUser userWxInfo = wxMpService.getUserService()
                .userInfo(wxMessage.getFromUser(), null);

        // 获取二维码信息
        WxQrcodeLogin qrcodeResult = wxRedis.getQrcodeResult(wxMessage.getTicket());
        String openId = userWxInfo.getOpenId();

        // 业务逻辑：查找或创建用户
        Long userId = findOrCreateUser(openId, userWxInfo);

        // 生成登录Token
        String token = generateToken(userId);

        // 更新登录状态
        wxRedis.loginSuccess(wxMessage.getTicket(), token);

        // 返回消息给用户
        return new TextBuilder().build("登录成功！", wxMessage, wxMpService);
    }
}
```

## 状态查询：前端的轮询机制

### 查询接口

前端需要轮询查询二维码状态，直到登录成功或二维码过期：

```java
@GetMapping("qrcode-result")
public CommonResult<WxQrcodeResultRespVo> userQrcodeResult(WxQrcodeResultReqVo reqVo) {
    WxQrcodeLogin qrcodeResult = wxRedis.getQrcodeResult(reqVo.getTicket());
    WxQrcodeResultRespVo respVo = new WxQrcodeResultRespVo();

    if (qrcodeResult == null) {
        // 二维码已过期
        respVo.setStatus(WxQrcodeStatus.EXPIRED.getValue());
    } else {
        respVo.setStatus(qrcodeResult.getStatus());
        respVo.setToken(qrcodeResult.getToken());

        // 如果已过期，清理缓存
        if (WxQrcodeStatus.EXPIRED.getValue().equals(qrcodeResult.getStatus())) {
            wxRedis.expireQrCode(reqVo.getTicket());
        }
    }

    return CommonResult.success(respVo);
}
```

## 踩坑指南：那些年我踩过的坑

### 1. 公众号类型选择问题

**问题**：个人订阅号无法获取用户详细信息
**解决方案**：
- 个人订阅号只能获取 OpenID
- 如需获取用户信息，必须使用认证服务号
- 测试环境可以使用微信测试号

### 2. URL配置的陷阱

**问题**：服务器配置URL验证失败
**解决方案**：
- URL 必须使用 80 或 443 端口
- 响应内容必须是纯文本的 echostr
- 签名验证必须准确无误
- 本地调试建议使用内网穿透工具

### 3. 二维码有效期管理

**问题**：二维码过期后仍在使用
**解决方案**：
- 设置合理的过期时间（推荐15分钟）
- 扫码后延长过期时间（推荐5分钟）
- 登录成功后短时间保留状态（推荐2分钟）


## 优化建议

### 1. 性能优化

```java
// 使用异步处理提高并发能力
@Async
public void handleLoginAsync(String ticket, String openId) {
    // 异步处理登录逻辑
}

// 使用缓存减少微信API调用
@Cacheable(value = "wxUserInfo", key = "#openId")
public WxMpUser getUserInfo(String openId) {
    // 缓存用户信息
}
```

### 2. 监控告警

```java
// 添加监控指标
@Component
public class WxLoginMetrics {
    private final MeterRegistry meterRegistry;

    public void recordLoginSuccess() {
        Counter.builder("wx.login.success")
                .register(meterRegistry)
                .increment();
    }
}
```

### 3. 异常处理

```java
@ControllerAdvice
public class WxExceptionHandler {

    @ExceptionHandler(WxErrorException.class)
    public CommonResult<String> handleWxError(WxErrorException e) {
        log.error("微信API调用异常", e);
        return CommonResult.error(500, "微信服务异常，请稍后重试");
    }
}
```


## 总结

经过两篇文章的分享，我们一起完成了一个完整的微信扫码登录系统,涉及了微信API、Redis缓存、消息路由、状态管理等多个技术点, 主要作为一个记录

**关键收获：**
1. 合理的架构设计是成功的基础
2. 状态管理是扫码登录的核心
3. 异常处理和安全性不容忽视
4. 持续优化才能构建稳定的服务

## 后续扩展方向

1. **支持多租户**：一个系统支持多个公众号
2. **扫码支付**：扩展到支付场景
3. **数据分析**：分析用户行为数据
4. **移动端适配**：支持H5内嵌登录

## 完整代码

本文的完整代码已上传至GitHub，欢迎参考和学习：[项目地址](https://github.com/xiaou66/weixin-java-mp-demo)

## 参考资源

- [微信扫码登录原理详解](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)
- [Redis最佳实践](https://redis.io/topics/memory-optimization)
- [Spring Boot异步处理](https://spring.io/guides/gs/async-method/)

---

*作者：xiaou
日期：2025年12月11日
感谢大家的阅读，有问题欢迎留言讨论！*